export const STRINGS = {
  uk: {
    // --- ЗАГАЛЬНІ КЛЮЧІ ІНТЕРФЕЙСУ ---
    header_left: "Курсова робота",
    header_center: "Розв'язання СЛАР",
    header_right: "Дерипаско О.В. КН-423а",
    tab_manual_input: "Ручне заповнення",
    tab_drag_drop: "Завантаження файлу",
    system_size_label: "Розмір системи N (1–9)",
    algorithm_label: "Алгоритм розв’язання",
    cramer_method: "Метод Крамера",
    gauss_method: "Метод Гауса",
    seidel_method: "Метод Зейделя",
    gauss_jordan_method: "Метод Гауса-Жордана",
    jacobi_method: "Метод Якобі",
    calculate_button: "Розрахувати",
    dropzone_title: "Перетягніть файл сюди",
    dropzone_or: "або",
    choose_file_button: "Обрати файл",
    result_title: "Результат",
    algorithm_display: "Алгоритм",
    no_result_message: "Немає результату.",
    back_to_input_button: "Назад до введення",
    language_switcher_label: "Мова",
    footer_text: "© 2025 Дерипаско Олексій. Всі права захищено.",

    // --- КЛЮЧІ ДЛЯ ПРОЦЕСУ РОЗРАХУНКУ ---
    step: "Крок",
    iteration: "Ітерація",
    iteration_title: "Ітерація {{it}}",
    iteration_summary: "Початок ітерації: x⁽{{it_minus_1}}⁾ = {{x_old}}\nРезультат ітерації: x⁽{{it}}⁾ = {{x_new}}\nНев'язка ‖Ax-b‖∞ = {{residual}},  Зміна Δ = {{delta}}",
    initial_matrix: "Початкова матриця та вектор",
    initial_augmented: "Початкова розширена матриця [A|b]",
    final_solution: "Підсумкове рішення",
    initial_solution_vector: "Початкове наближення вектора розв’язку",
    cramer_det_main: "Обчислення визначника головної матриці A",
    cramer_det_Ai_tpl: "Обчислення визначника матриці A{{i}}",
    cramer_calc_xi: "Обчислення x{{i}}",
    gauss_swap_rows: "Міняємо рядки {{r1}} та {{r2}}, щоб опорний елемент був максимальним.",
    gauss_eliminate_step_title: "Елімінація для рядка {{targetRow}}", // ПОВЕРНУТО
    gauss_eliminate_details: "Коефіцієнт k = A[{{targetRow}}][{{col}}] / A[{{sourceRow}}][{{col}}] = {{val_ik}} / {{val_kk}} = {{factor}}.\nВід рядка {{targetRow}} віднімаємо рядок {{sourceRow}}, помножений на k.",
    final_solution_back: "Зворотний хід: обчислення розв'язку",
    final_triangular_matrix: "Матриця після прямого ходу",
    gj_initial_matrix: "Початкова розширена матриця",
    gj_swap_rows: "Обмін рядків {{r1}} та {{r2}} для вибору максимального опорного елемента",
    gj_normalize_row_title: "Нормалізація рядка {{row}}",
    gj_normalize_row_details: "Ділимо весь рядок на опорний елемент ({{pivotVal}}), щоб отримати 1 на діагоналі.",
    gj_eliminate_row_title: "Елімінація для рядка {{targetRow}}",
    gj_eliminate_row_details: "Від рядка {{targetRow}} віднімаємо опорний рядок {{sourceRow}}, помножений на {{factor}}.",
    gj_final_matrix: "Результат: зліва одинична матриця, справа – розв'язок",

    cramer_det_Ai_tpl: "Обчислення визначника матриці A{{i}}",

    // --- ПОМИЛКИ ВВЕДЕННЯ ТА ОБРОБКИ ---
    error_prefix: "Помилка",
    invalid_value_a: "Некоректне значення a{{r}}{{c}}",
    invalid_value_b: "Некоректне значення b{{r}}",
    singular_system_error: "Система вироджена або має нескінченно багато розв’язків.",
    zero_diagonal_error: "Нуль на діагоналі.",
    jacobi_not_diag_dom: "Матриця не є діагонально домінантною. Метод Якобі може не збігатися.",
    seidel_not_diag_dom: "Матриця не є діагонально домінантною. Метод Зейделя може не збігатися.",
    jacobi_not_converged: "Метод Якобі не збігся протягом максимального числа ітерацій.",
    seidel_not_converged: "Метод Зейделя не збігся протягом максимального числа ітерацій.",
    success_file_parsed: "Файл успішно оброблено!",
    error_file_empty: "Файл порожній або не містить значущих даних.",
    error_file_read: "Не вдалося прочитати файл. Можливо, він пошкоджений або у вас немає прав доступу.",
    error_n_out_of_bounds: "Розмір системи N={{n}} поза допустимим діапазоном (1–9).",
    error_non_numeric: "Нечислове значення «{{s}}» (рядок {{r}}, стовпець {{c}}).",
    error_row_expected_len: "У рядку {{r}} має бути {{expected}} значень (A|b), отримано {{actual}}.",
    error_first_line_must_be_n: "Перший рядок файлу має містити лише число N — кількість рівнянь.",
    error_expected_rows_n: "Після рядка з N очікується {{n}} рядків, отримано {{actual}}.",

    // --- МЕТОДИЧНІ ВКАЗІВКИ ---
    guidelines_title: "Методичні вказівки",
    algorithms_short_title: "Огляд алгоритмів розв'язання",
    method_requirements_title: "Умови застосування методів",
    file_requirements_title: "Вимоги до файлу вхідних даних",
    file_format_title: "Формат та структура файлу",

    algo_cramer_full_desc: "Це прямий (точний) метод, де кожен невідомий $x_j$ обчислюється за формулою Крамера. $$x_j = \\frac{\\det(A_j)}{\\det(A)}$$ Тут $\\det(A)$ — визначник основної матриці коефіцієнтів, а $\\det(A_j)$ — визначник матриці, отриманої шляхом заміни j-го стовпця на стовпець вільних членів. Метод є точним, але через високу обчислювальну складність та чутливість до похибок округлення його доцільно використовувати лише для систем малої розмірності (N ≤ 4).",
    algo_gauss_full_desc: "Класичний прямий метод, що складається з двох етапів. <br><b>1. Прямий хід:</b> Систему рівнянь шляхом послідовного виключення невідомих зводять до еквівалентної системи з верхньою трикутною матрицею. Для зменшення похибок обчислень часто використовують техніку вибору головного (найбільшого за модулем) елемента. <br><b>2. Зворотний хід:</b> Відбувається послідовне знаходження невідомих, починаючи з останнього рівняння.",
    algo_gj_full_desc: "Це модифікація методу Гауса. Процес виключення невідомих (прямий хід) продовжується доти, доки матриця коефіцієнтів не перетвориться на одиничну. У результаті цих перетворень стовпець вільних членів автоматично перетворюється на вектор розв'язків системи. Цей метод не потребує окремого етапу зворотного ходу, що спрощує алгоритм.",
    algo_jacobi_full_desc: "Ітераційний метод, який також називають методом послідовних наближень. Задається початкове наближення $X^{(0)}$ (часто нульовий вектор). Кожне наступне наближення $X^{(k+1)}$ обчислюється за формулою, що використовує значення <em>лише</em> з попередньої ітерації $X^{(k)}$. $$x_i^{(k+1)} = \\frac{1}{a_{ii}} \\left( b_i - \\sum_{j \\neq i} a_{ij} x_j^{(k)} \\right)$$ Процес продовжується доти, доки різниця між послідовними наближеннями не стане меншою за задану точність $\\epsilon$.",
    algo_seidel_full_desc: "Це вдосконалена версія ітераційного методу Якобі. Головна відмінність полягає в тому, що при обчисленні компоненти $x_i^{(k+1)}$ на поточній ітерації використовуються вже обчислені на <b>цій самій</b> ітерації значення $x_1^{(k+1)}, \\dots, x_{i-1}^{(k+1)}$. $$x_i^{(k+1)} = \\frac{1}{a_{ii}} \\left( b_i - \\sum_{j < i} a_{ij} x_j^{(k+1)} - \\sum_{j > i} a_{ij} x_j^{(k)} \\right)$$ Це у більшості випадків призводить до швидшої збіжності процесу порівняно з методом Якобі.",

    method_req_cramer_full_desc: "<b>1. Розмірність (N ≤ 4):</b> Кількість обчислень зростає дуже швидко, що робить метод неефективним для великих систем. <br><b>2. Невиродженість ($\\det(A) \\neq 0$):</b> Якщо визначник основної матриці дорівнює нулю, система або не має розв'язків, або має їх нескінченну кількість, і формула Крамера стає незастосовною.",
    method_req_iterative_full_desc: "Для гарантованої збіжності ітераційних методів (Якобі та Зейделя) до єдиного розв'язку, незалежно від вибору початкового наближення, достатньо, щоб матриця коефіцієнтів $A$ мала <b>діагональне переважання</b>. Це означає, що для кожного рядка модуль діагонального елемента повинен бути строго більшим за суму модулів усіх інших елементів у цьому рядку. $$|a_{kk}| > \\sum_{j \\neq k} |a_{kj}|$$ Якщо ця умова не виконується, метод може розбігатися.",
    method_req_gauss_full_desc: "Методи Гауса та Гауса-Жордана є універсальними і найнадійнішими для розв'язання систем лінійних рівнянь загального вигляду. Єдина ключова вимога — матриця коефіцієнтів $A$ повинна бути <b>невиродженою</b> (тобто $\\det(A) \\neq 0$), що гарантує існування єдиного розв'язку.",
    
    file_requirements_full_desc: "Для коректної обробки файл повинен відповідати наступному формату:",
    file_format_N: "<b>Рядок 1:</b> Одне ціле число N — порядок системи (кількість рівнянь).",
    file_format_Matrix: "<b>Наступні N рядків:</b> Кожен рядок представляє собою рядок розширеної матриці <code>[A|b]</code>, тобто містить N коефіцієнтів матриці А та (N+1)-й елемент — відповідний вільний член з вектора b.",
    file_format_Separator: "<b>Розділювач:</b> Усі числа в рядку повинні бути розділені пробілами.",
    file_example_title: "Приклад файлу для N=3",
    file_example_content: `3 <span class="comment"># Порядок системи</span>\n2.5 -1.0 4.2 10.1 <span class="comment"># a11 a12 a13 b1</span>\n1.1  6.0 -0.5 15.7 <span class="comment"># a21 a22 a23 b2</span>\n0.8  2.3  5.4 20.0 <span class="comment"># a31 a32 a33 b3</span>`,
  },

  en: {
    // --- GENERAL UI KEYS ---
    header_left: "Coursework",
    header_center: "Solution of SLAE",
    header_right: "Derypasko O.V. CS-423a",
    tab_manual_input: "Manual Input",
    tab_drag_drop: "File Upload",
    system_size_label: "System Size N (1–9)",
    algorithm_label: "Solution Algorithm",
    cramer_method: "Cramer's Method",
    gauss_method: "Gauss's Method",
    seidel_method: "Seidel's Method",
    gauss_jordan_method: "Gauss-Jordan Method",
    jacobi_method: "Jacobi's Method",
    calculate_button: "Calculate",
    dropzone_title: "Drag & drop file here",
    dropzone_or: "or",
    choose_file_button: "Choose File",
    result_title: "Result",
    algorithm_display: "Algorithm",
    no_result_message: "No result.",
    back_to_input_button: "Back to Input",
    language_switcher_label: "Language",
    footer_text: "© 2025 Derypasko Oleksii. All rights reserved.",

    // --- CALCULATION PROCESS KEYS ---
    step: "Step",
    iteration: "Iteration",
    iteration_title: "Iteration {{it}}",
    iteration_summary: "Start of iteration: x⁽{{it_minus_1}}⁾ = {{x_old}}\nEnd of iteration: x⁽{{it}}⁾ = {{x_new}}\nResidual ‖Ax-b‖∞ = {{residual}},  Change Δ = {{delta}}",
    initial_matrix: "Initial matrix and vector",
    initial_augmented: "Initial augmented matrix [A|b]",
    final_solution: "Final solution",
    initial_solution_vector: "Initial solution vector",
    cramer_det_main: "Calculate the determinant of the main matrix A",
    cramer_det_Ai_tpl: "Calculate the determinant of matrix A{{i}}",
    cramer_calc_xi: "Calculate x{{i}}",
    gauss_swap_rows: "Swap rows {{r1}} and {{r2}} to maximize the pivot element.",
    gauss_eliminate_step_title: "Elimination for row {{targetRow}}", // RESTORED
    gauss_eliminate_details: "Factor k = A[{{targetRow}}][{{col}}] / A[{{sourceRow}}][{{col}}] = {{val_ik}} / {{val_kk}} = {{factor}}.\nSubtract row {{sourceRow}} * k from row {{targetRow}}.",
    final_solution_back: "Back Substitution: Calculating the solution",
    final_triangular_matrix: "Matrix after forward elimination",
    gj_initial_matrix: "Initial Augmented Matrix",
    gj_swap_rows: "Swap rows {{r1}} and {{r2}} to select the maximal pivot element",
    gj_normalize_row_title: "Normalize row {{row}}",
    gj_normalize_row_details: "Divide the entire row by the pivot element ({{pivotVal}}) to get a 1 on the diagonal.",
    gj_eliminate_row_title: "Elimination for row {{targetRow}}",
    gj_eliminate_row_details: "Subtract pivot row {{sourceRow}} multiplied by {{factor}} from row {{targetRow}}.",
    gj_final_matrix: "Result: Identity matrix on the left, solution on the right",

    cramer_det_Ai_tpl: "Calculate the determinant of matrix A{{i}}",
    // --- INPUT & PROCESSING ERRORS ---
    error_prefix: "Error",
    invalid_value_a: "Invalid value a{{r}}{{c}}",
    invalid_value_b: "Invalid value b{{r}}",
    singular_system_error: "The system is singular or has infinitely many solutions.",
    zero_diagonal_error: "Zero on the diagonal.",
    jacobi_not_diag_dom: "Matrix is not diagonally dominant. Jacobi may not converge.",
    seidel_not_diag_dom: "Matrix is not diagonally dominant. Seidel may not converge.",
    jacobi_not_converged: "Jacobi method did not converge within the maximum number of iterations.",
    seidel_not_converged: "Seidel method did not converge within the maximum number of iterations.",
    success_file_parsed: "File parsed successfully!",
    error_file_empty: "The file is empty or contains no meaningful data.",
    error_file_read: "Failed to read the file. It might be corrupted or you may not have access permissions.",
    error_n_out_of_bounds: "N={{n}} is out of allowed range (1–9).",
    error_non_numeric: "Non-numeric value \"{{s}}\" at row {{r}}, col {{c}}.",
    error_row_expected_len: "Row {{r}} must contain {{expected}} values (A|b), got {{actual}}.",
    error_first_line_must_be_n: "The first line must contain only N — the number of equations.",
    error_expected_rows_n: "Expected {{n}} lines after N, got {{actual}}.",
    
    // --- METHODICAL GUIDELINES ---
    guidelines_title: "Methodical Guidelines",
    algorithms_short_title: "Overview of Solution Algorithms",
    method_requirements_title: "Method Application Conditions",
    file_requirements_title: "Input File Requirements",
    file_format_title: "File Format and Structure",

    algo_cramer_full_desc: "This is a direct (exact) method where each unknown $x_j$ is calculated using Cramer's rule. $$x_j = \\frac{\\det(A_j)}{\\det(A)}$$ Here, $\\det(A)$ is the determinant of the main coefficient matrix, and $\\det(A_j)$ is the determinant of the matrix obtained by replacing the j-th column with the column of free terms. The method is precise but computationally expensive and sensitive to rounding errors, making it suitable only for small systems (N ≤ 4).",
    algo_gauss_full_desc: "A classic direct method consisting of two stages. <br><b>1. Forward Elimination:</b> The system is reduced to an equivalent system with an upper triangular matrix by sequentially eliminating variables. Pivoting (selecting the largest absolute value element) is often used to reduce computational errors. <br><b>2. Back Substitution:</b> The unknowns are found sequentially, starting from the last equation.",
    algo_gj_full_desc: "A modification of the Gauss method. The elimination process is continued until the coefficient matrix becomes an identity matrix. As a result, the column of free terms transforms into the solution vector. This method avoids the separate back substitution step, simplifying the algorithm.",
    algo_jacobi_full_desc: "An iterative method, also known as the method of successive approximations. An initial guess $X^{(0)}$ (often a zero vector) is chosen. Each subsequent approximation $X^{(k+1)}$ is calculated using values <em>only</em> from the previous iteration $X^{(k)}$. $$x_i^{(k+1)} = \\frac{1}{a_{ii}} \\left( b_i - \\sum_{j \\neq i} a_{ij} x_j^{(k)} \\right)$$ The process continues until the difference between successive approximations is less than a given tolerance $\\epsilon$.",
    algo_seidel_full_desc: "An improved version of the Jacobi method. The main difference is that when computing the component $x_i^{(k+1)}$, it immediately uses the already computed values $x_1^{(k+1)}, \\dots, x_{i-1}^{(k+1)}$ from the <b>current</b> iteration. $$x_i^{(k+1)} = \\frac{1}{a_{ii}} \\left( b_i - \\sum_{j < i} a_{ij} x_j^{(k+1)} - \\sum_{j > i} a_{ij} x_j^{(k)} \\right)$$ This typically leads to faster convergence compared to the Jacobi method.",
    
    method_req_cramer_full_desc: "<b>1. Dimension (N ≤ 4):</b> The number of calculations grows rapidly, making the method inefficient for larger systems. <br><b>2. Non-singularity ($\\det(A) \\neq 0$):</b> If the determinant is zero, the system has no unique solution, and Cramer's rule is not applicable.",
    method_req_iterative_full_desc: "For guaranteed convergence of iterative methods (Jacobi and Seidel), it is sufficient for the matrix $A$ to be <b>diagonally dominant</b>. This means that for each row, the absolute value of the diagonal element must be strictly greater than the sum of the absolute values of all other elements in that row. $$|a_{kk}| > \\sum_{j \\neq k} |a_{kj}|$$ If this condition is not met, the method may diverge.",
    method_req_gauss_full_desc: "Gauss and Gauss-Jordan methods are universal and robust for solving general linear systems. The only key requirement is that the matrix $A$ must be <b>non-singular</b> (i.e., $\\det(A) \\neq 0$), which guarantees a unique solution.",
    
    file_requirements_full_desc: "For correct parsing, the file must adhere to the following format:",
    file_format_N: "<b>Line 1:</b> A single integer N — the order of the system.",
    file_format_Matrix: "<b>Next N lines:</b> Each line represents a row of the augmented matrix <code>[A|b]</code>, containing N coefficients and the (N+1)-th element, which is the corresponding free term.",
    file_format_Separator: "<b>Separator:</b> All numbers in a line must be separated by spaces.",
    file_example_title: "File example for N=3",
    file_example_content: `3 <span class="comment"># System order</span>\n2.5 -1.0 4.2 10.1 <span class="comment"># a11 a12 a13 b1</span>\n1.1  6.0 -0.5 15.7 <span class="comment"># a21 a22 a23 b2</span>\n0.8  2.3  5.4 20.0 <span class="comment"># a31 a32 a33 b3</span>`,
  },
};