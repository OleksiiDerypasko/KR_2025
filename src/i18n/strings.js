export const STRINGS = {
  uk: {
    header_left: "Курсова робота",
    header_center: "Розв'язання СЛАР",
    header_right: "Дерипаско О.В. КН-423а",
    tab_manual_input: "Ручне заповнення",
    tab_drag_drop: "Завантаження файлу",
    guidelines_title: "Методичні вказівки",
    system_size_label: "Розмір системи N (1–9)",
    algorithm_label: "Алгоритм розв’язання",
    cramer_method: "Метод Крамера",
    gauss_method: "Метод Гауса",
    seidel_method: "Метод Зейделя",
    gauss_jordan_method: "Метод Гауса-Жордана",
    jacobi_method: "Метод Якобі",
    calculate_button: "Розрахувати",
    error_prefix: "Помилка",
    invalid_value_a: "Некоректне значення a{{r}}{{c}}",
    invalid_value_b: "Некоректне значення b{{r}}",
    singular_system_error: "Система вироджена або має нескінченно багато розв’язків.",
    zero_diagonal_error: "Нуль на діагоналі.",
    dropzone_title: "Перетягніть файл сюди",
    dropzone_or: "або",
    choose_file_button: "Обрати файл",
    result_title: "Результат",
    algorithm_display: "Алгоритм",
    no_result_message: "Немає результату.",
    back_to_input_button: "Назад до введення",
    language_switcher_label: "Мова",
    footer_text: "© 2025 Дерипаско Олексій. Всі права захищено.",

    step: "Крок",
    iteration: "Ітерація",
    initial_matrix: "Початкова матриця та вектор",
    initial_augmented: "Початкова розширена матриця [A|b]",
    swapped_rows_tpl: "Обмін рядків {{a}} ↔ {{b}} (макс. опорний елемент)",
    forward_elimination_tpl: "Прямий хід для стовпця {{col}}",
    normalize_row_tpl: "Нормалізація рядка {{row}}",
    eliminate_column_tpl: "Занулення стовпця {{col}}",
    final_solution: "Підсумкове рішення",
    final_solution_back: "Підсумкове рішення після зворотного ходу",
    initial_solution_vector: "Початкове наближення вектора розв’язку",
    cramer_det_main: "Обчислення визначника головної матриці A",
    cramer_det_Ai_tpl: "Обчислення визначника матриці A{{i}}",

    file_requirements_title: "Вимоги до файлу вхідних даних",
    file_req_1: "Файл повинен містити квадратну матрицю коефіцієнтів A та вектор b.",
    file_req_2: "Розділювач між числами — пробіл або кома.",
    file_req_3: "Кількість рядків і стовпців має збігатися (матриця n×n).",
    method_requirements_title: "Вимоги до вибору методу",
    method_req_cramer: "Метод Крамера: n ≤ 4, det(A) ≠ 0.",
    method_req_gauss: "Метод Гауса: допускає будь-яку квадратну невироджену систему.",
    method_req_gj: "Метод Гауса–Жордана: аналогічно методу Гауса, але з повною редукцією.",
    method_req_jacobi: "Метод Якобі: матриця повинна бути діагонально домінантною.",
    method_req_seidel: "Метод Зейделя: потребує діагональної домінантності для збіжності.",

    algorithms_short_title: "Короткі відомості про алгоритми",
    algorithms_intro: "У програмі реалізовано п’ять методів розв’язання СЛАР:",
    algo_cramer_desc: "аналітичний метод, що обчислює невідомі через відношення визначників (A_i / det(A)).",
    algo_gauss_desc: "послідовне виключення невідомих за допомогою трикутного перетворення матриці.",
    algo_gj_desc: "розширений варіант Гауса з приведенням до одиничної матриці.",
    algo_jacobi_desc: "ітераційний метод, де нові значення x обчислюються із попередніх незалежно.",
    algo_seidel_desc: "модифікація Якобі, що використовує оновлені значення всередині ітерації.",

    jacobi_not_diag_dom: "Матриця не є діагонально домінантною. Метод Якобі може не збігатися.",
    seidel_not_diag_dom: "Матриця не є діагонально домінантною. Метод Зейделя може не збігатися.",
    jacobi_not_converged: "Метод Якобі не збігся протягом максимального числа ітерацій.",
    seidel_not_converged: "Метод Зейделя не збігся протягом максимального числа ітерацій.",

    success_file_parsed: "Файл успішно оброблено!",
    error_file_empty: "Файл порожній або не містить значущих даних. Переконайтеся, що він містить числа.",
    error_file_read: "Не вдалося прочитати файл. Можливо, він пошкоджений або у вас немає прав доступу.",
    error_n_out_of_bounds: "Розмір системи N, вказаний у першому рядку, дорівнює {{n}}. Він має бути в межах від 1 до 9.",
    error_n_derived_out_of_bounds: "Автоматично визначений розмір системи N дорівнює {{n}} (за структурою файлу). Він має бути в межах від 1 до 9.",
    error_non_numeric: "Значення '{{s}}' у рядку {{r}}, стовпці {{c}} не є числом. Перевірте дані у файлі.",
    error_structure_mismatch: "Структура файлу не відповідає очікуванням. Для N={{n}} очікувалося {{n}} або {{n_plus_1}} рядків з даними, але у файлі їх {{actual}}.",
    error_augmented_row_length: "Помилка структури розширеної матриці. Рядок {{r}} повинен містити {{expected}} чисел (N+1), але знайдено {{actual}}.",
    error_matrix_a_row_length: "Помилка структури матриці A. Рядок {{r}} повинен містити {{expected}} чисел (N), але знайдено {{actual}}.",
    error_vector_b_length: "Помилка структури вектора B. Останній рядок файлу повинен містити {{expected}} чисел (N), але знайдено {{actual}}.",
    error_n_undefined: "Не вдалося автоматично визначити розмір системи N. Перевірте структуру файлу або вкажіть N у першому рядку.",
    ERR_INVALID_A_tpl: "Некоректне значення a{{r}}{{c}}. Перевірте введені дані.",
ERR_INVALID_B_tpl: "Некоректне значення b{{r}}. Вектор правих частин містить помилки.",
ERR_SINGULAR_tpl: "Система вироджена або має нескінченно багато розв’язків.",
ERR_ZERO_DIAG_tpl: "Нульовий елемент на головній діагоналі.",
ERR_NO_SOLUTION_tpl: "Розв’язок не знайдено.",
    // --- ОНОВЛЕНІ ТА НОВІ КЛЮЧІ ---
    algorithms_short_title: "Короткі відомості про алгоритми",
    method_requirements_title: "Вимоги до вибору методу",
    file_requirements_title: "Вимоги до файлу вхідних даних",

    // Короткі описи (залишаються для можливого використання)
    algo_cramer_desc: "аналітичний метод, що обчислює невідомі через відношення визначників.",
    algo_gauss_desc: "послідовне виключення невідомих для отримання трикутної матриці.",
    algo_gj_desc: "модифікація методу Гауса з приведенням до одиничної матриці.",
    algo_jacobi_desc: "ітераційний метод, де нові значення обчислюються незалежно.",
    algo_seidel_desc: "ітераційний метод, що використовує оновлені значення всередині ітерації.",

    // РОЗШИРЕНІ ОПИСИ АЛГОРИТМІВ
     algo_cramer_full_desc: "Це прямий аналітичний метод, де кожен невідомий \\(x_j\\) обчислюється за формулою Крамера: \\(x_j = \\frac{\\det(A_j)}{\\det(A)}\\)[cite: 41].  Тут \\(\\det(A)\\) — визначник основної матриці коефіцієнтів, а \\(\\det(A_j)\\) — визначник матриці, отриманої шляхом заміни j-го стовпця на стовпець вільних членів[cite: 42].  Метод є точним, але через високу обчислювальну складність (велика кількість операцій) та чутливість до похибок округлення його доцільно використовувати лише для систем малої розмірності (N ≤ 4)[cite: 43, 44, 45].",
    algo_gauss_full_desc: "Класичний прямий метод, що складається з двох етапів.  На першому етапі (**прямий хід**) система рівнянь шляхом послідовного виключення невідомих зводиться до еквівалентної системи з верхньою трикутною матрицею[cite: 47].  Для зменшення похибок обчислень часто використовують техніку вибору головного (найбільшого за модулем) елемента[cite: 77].  На другому етапі (**зворотний хід**) відбувається послідовне знаходження невідомих, починаючи з останнього рівняння, де залишилась лише одна змінна[cite: 72, 74, 75].",
    algo_gj_full_desc: "Це модифікація методу Гауса. Процес виключення невідомих (прямий хід) продовжується доти, доки матриця коефіцієнтів не перетвориться на одиничну (діагональну матрицю з одиницями на головній діагоналі). У результаті цих перетворень стовпець вільних членів автоматично перетворюється на вектор розв'язків системи. Цей метод не потребує окремого етапу зворотного ходу, що спрощує алгоритм.",
    algo_jacobi_full_desc: "Ітераційний метод, який також називають методом послідовних наближень.  Вихідна система \\(AX=B\\) зводиться до вигляду \\(X = CX+D\\)[cite: 209].  Задається початкове наближення \\(X^{(0)}\\) (часто нульовий вектор)[cite: 179].  Кожне наступне наближення \\(X^{(k+1)}\\) обчислюється за формулами, що використовують значення *лише* з попередньої ітерації \\(X^{(k)}\\)[cite: 195].  Процес продовжується доти, доки різниця між послідовними наближеннями не стане меншою за задану точність \\(\\epsilon\\)[cite: 204].",
     algo_seidel_full_desc: "Це вдосконалена версія ітераційного методу Якобі[cite: 217].  Головна відмінність полягає в тому, що при обчисленні компоненти \\(x_i^{(k+1)}\\) на поточній ітерації використовуються вже обчислені на цій же ітерації значення \\(x_1^{(k+1)}, \\dots, x_{i-1}^{(k+1)}\\)[cite: 217].  Це дозволяє інформації про зміни поширюватися швидше, що у більшості випадків призводить до швидшої збіжності процесу порівняно з методом Якобі[cite: 228].",

    // РОЗШИРЕНІ ВИМОГИ ДО МЕТОДІВ
    method_req_cramer_full_desc: "<b>1.  Розмірність (N ≤ 4):</b> Кількість обчислень визначників зростає дуже швидко, що робить метод неефективним для великих систем[cite: 44]. <br><b>2.  Невиродженість (det(A) ≠ 0):</b> Якщо визначник основної матриці дорівнює нулю, система або не має розв'язків, або має їх нескінченну кількість, і формула Крамера стає незастосовною[cite: 35, 40].",
     method_req_iterative_full_desc: "Для гарантованої збіжності ітераційних методів (Якобі та Зейделя) до єдиного розв'язку, незалежно від вибору початкового наближення, достатньо, щоб матриця коефіцієнтів \\(A\\) мала **діагональне переважання**[cite: 117].  Це означає, що для кожного рядка модуль діагонального елемента повинен бути строго більшим за суму модулів усіх інших елементів у цьому рядку: \\(|a_{kk}| > \\sum_{j \\neq k} |a_{kj}|\\)[cite: 118]. Якщо ця умова не виконується, метод може розбігатися.",
     method_req_gauss_full_desc: "Методи Гауса та Гауса-Жордана є універсальними і найнадійнішими для розв'язання систем лінійних рівнянь загального вигляду[cite: 232, 233]. Єдина ключова вимога — матриця коефіцієнтів \\(A\\) повинна бути **невиродженою** (тобто \\(\\det(A) \\neq 0\\)), що гарантує існування єдиного розв'язку. Вони застосовні до будь-яких квадратних систем, незалежно від інших властивостей матриці.",
    
    // РОЗШИРЕНІ ВИМОГИ ДО ФАЙЛУ
    file_requirements_full_desc: "Для коректної обробки файл повинен відповідати наступному формату:",
    file_format_N: "<b>Рядок 1:</b> Одне ціле число N — порядок системи (кількість рівнянь).",
    file_format_Matrix: "<b>Наступні N рядків:</b> Кожен рядок представляє собою рядок розширеної матриці `[A|b]`, тобто містить N коефіцієнтів матриці А та (N+1)-й елемент — відповідний вільний член з вектора b.",
    file_format_Separator: "<b>Розділювач:</b> Усі числа в рядку повинні бути розділені пробілами.",
    
    file_example_title: "Приклад файлу для N=3",
    file_example_content: `3 <span class="comment"># Порядок системи</span>
2.5 -1.0 4.2 10.1 <span class="comment"># a11 a12 a13 b1</span>
1.1  6.0 -0.5 15.7 <span class="comment"># a21 a22 a23 b2</span>
0.8  2.3  5.4 20.0 <span class="comment"># a31 a32 a33 b3</span>`,
error_first_line_must_be_n: "Перший рядок файлу має містити лише число N — кількість рівнянь.",
error_n_out_of_bounds: "Значення N={{n}} поза допустимим діапазоном (1–9).",
error_expected_rows_n: "Після рядка з N очікується {{n}} рядків, отримано {{actual}}.",
error_row_expected_len: "У рядку {{r}} має бути {{expected}} значень (A|b), отримано {{actual}}.",
error_non_numeric: "Нечислове значення «{{s}}» (рядок {{r}}, стовпець {{c}}).",
error_file_empty: "Файл порожній.",
error_file_read: "Не вдалося прочитати файл.",
success_file_parsed: "Файл успішно оброблено!",
cramer_det_Ai: "Обчислення визначника матриці A{{i}}",
  },

  en: {
    header_left: "Coursework",
    header_center: "Solution of SLAE",
    header_right: "Derypasko Oleksii CS-423a",
    tab_manual_input: "Manual Input",
    tab_drag_drop: "Drag & Drop",
    guidelines_title: "Methodical Guidelines",
    system_size_label: "System Size N (1–9)",
    algorithm_label: "Solution Algorithm",
    cramer_method: "Cramer's method",
    gauss_method: "Gauss's method",
    seidel_method: "Seidel's method",
    gauss_jordan_method: "Gauss-Jordan method",
    jacobi_method: "Jacobi's method",
    calculate_button: "Calculate",
    error_prefix: "Error",
    invalid_value_a: "Invalid value a{{r}}{{c}}",
    invalid_value_b: "Invalid value b{{r}}",
    singular_system_error: "System is singular or has infinitely many solutions.",
    zero_diagonal_error: "Zero on diagonal.",
    dropzone_title: "Drag & drop file here",
    dropzone_or: "or",
    choose_file_button: "Choose File",
    result_title: "Result",
    algorithm_display: "Algorithm",
    no_result_message: "No result.",
    back_to_input_button: "Back to input",
    language_switcher_label: "Language",
    footer_text: "© 2025 Derypasko Oleksii. All rights reserved.",

    step: "Step",
    iteration: "Iteration",
    initial_matrix: "Initial matrix and vector",
    initial_augmented: "Initial augmented matrix [A|b]",
    swapped_rows_tpl: "Swap rows {{a}} ↔ {{b}} (max pivot)",
    forward_elimination_tpl: "Forward elimination for column {{col}}",
    normalize_row_tpl: "Normalize row {{row}}",
    eliminate_column_tpl: "Eliminate column {{col}}",
    final_solution: "Final solution",
    final_solution_back: "Final solution after back substitution",
    initial_solution_vector: "Initial solution vector",
    cramer_det_main: "Calculate the determinant of the main matrix A",
    cramer_det_Ai_tpl: "Calculate the determinant of matrix A{{i}}",

    file_requirements_title: "Input File Requirements",
    file_req_1: "The file must contain a square coefficient matrix A and vector b.",
    file_req_2: "Numbers are separated by spaces or commas.",
    file_req_3: "The number of rows and columns must match (square matrix).",
    method_requirements_title: "Method Selection Requirements",
    method_req_cramer: "Cramer's method: n ≤ 4, det(A) ≠ 0.",
    method_req_gauss: "Gauss method: any square non-singular system.",
    method_req_gj: "Gauss–Jordan: full reduction to identity matrix.",
    method_req_jacobi: "Jacobi: matrix must be diagonally dominant.",
    method_req_seidel: "Seidel: also requires diagonal dominance for convergence.",

    algorithms_short_title: "Short Description of Algorithms",
    algorithms_intro: "The application implements five classical SLAE solution methods:",
    algo_cramer_desc: "Analytical method using determinants (A_i / det(A)).",
    algo_gauss_desc: "Sequential elimination of variables via triangular form.",
    algo_gj_desc: "Extended Gauss method with full matrix reduction.",
    algo_jacobi_desc: "Iterative method updating all x-values independently each iteration.",
    algo_seidel_desc: "Jacobi’s modification using updated x-values during iteration.",

    jacobi_not_diag_dom: "Matrix is not diagonally dominant. Jacobi may not converge.",
    seidel_not_diag_dom: "Matrix is not diagonally dominant. Seidel may not converge.",
    jacobi_not_converged: "Jacobi method did not converge within the maximum number of iterations.",
    seidel_not_converged: "Seidel method did not converge within the maximum number of iterations.",

    success_file_parsed: "File parsed successfully!",
    error_file_empty: "The file is empty or contains no meaningful data. Please ensure it contains numbers.",
    error_file_read: "Failed to read the file. It might be corrupted or you may not have access permissions.",
    error_n_out_of_bounds: "The system size N specified in the first line is {{n}}. It must be between 1 and 9.",
    error_n_derived_out_of_bounds: "The auto-detected system size N is {{n}} (based on file structure). It must be between 1 and 9.",
    error_non_numeric: "The value '{{s}}' in row {{r}}, column {{c}} is not a number. Please check the data in the file.",
    error_structure_mismatch: "The file structure does not match expectations. For N={{n}}, {{n}} or {{n_plus_1}} data rows were expected, but the file has {{actual}}.",
    error_augmented_row_length: "Augmented matrix structure error. Row {{r}} should contain {{expected}} numbers (N+1), but {{actual}} were found.",
    error_matrix_a_row_length: "Matrix A structure error. Row {{r}} should contain {{expected}} numbers (N), but {{actual}} were found.",
    error_vector_b_length: "Vector B structure error. The last line of the file should contain {{expected}} numbers (N), but {{actual}} were found.",
    error_n_undefined: "Could not automatically determine the system size N. Check the file structure or specify N in the first line.",
    ERR_INVALID_A_tpl: "Invalid value a{{r}}{{c}}. Please check your input data.",
ERR_INVALID_B_tpl: "Invalid value b{{r}}. The right-hand side vector contains errors.",
ERR_SINGULAR_tpl: "The system is singular or has infinitely many solutions.",
ERR_ZERO_DIAG_tpl: "Zero element on the main diagonal.",
ERR_NO_SOLUTION_tpl: "No solution found.",
    // ... аналогічні ключі англійською ...
    // Я додам лише нові та змінені для прикладу
    algorithms_short_title: "Brief Information on Algorithms",
    method_requirements_title: "Method Selection Requirements",
    file_requirements_title: "Input File Requirements",

     algo_cramer_full_desc: "A direct analytical method where each unknown \\(x_j\\) is calculated using Cramer's rule: \\(x_j = \\frac{\\det(A_j)}{\\det(A)}\\)[cite: 41].  Here, \\(\\det(A)\\) is the determinant of the main coefficient matrix, and \\(\\det(A_j)\\) is the determinant of the matrix obtained by replacing the j-th column with the column of free terms[cite: 42].  The method is precise but computationally expensive and sensitive to rounding errors, making it suitable only for small systems (N ≤ 4)[cite: 43, 44, 45].",
    algo_gauss_full_desc: "A classic direct method consisting of two stages.  In the first stage (**forward elimination**), the system is reduced to an equivalent system with an upper triangular matrix by sequentially eliminating variables[cite: 47].  Pivoting (selecting the largest element) is often used to reduce computational errors[cite: 77].  In the second stage (**back substitution**), the unknowns are found sequentially, starting from the last equation[cite: 72, 74, 75].",
    algo_gj_full_desc: "A modification of the Gauss method. The elimination process is continued until the coefficient matrix becomes an identity matrix. As a result, the column of free terms transforms into the solution vector. This method avoids the separate back substitution step, simplifying the algorithm.",
    algo_jacobi_full_desc: "An iterative method, also known as the method of successive approximations.  The system \\(AX=B\\) is rewritten as \\(X = CX+D\\)[cite: 209].  An initial guess \\(X^{(0)}\\) is chosen (often a zero vector)[cite: 179].  Each subsequent approximation \\(X^{(k+1)}\\) is calculated using values *only* from the previous iteration \\(X^{(k)}\\)[cite: 195].  The process continues until the difference between successive approximations is less than a given tolerance \\(\\epsilon\\)[cite: 204].",
     algo_seidel_full_desc: "An improved version of the Jacobi iterative method[cite: 217].  The main difference is that when computing the component \\(x_i^{(k+1)}\\), it immediately uses the already computed values \\(x_1^{(k+1)}, \\dots, x_{i-1}^{(k+1)}\\) from the current iteration[cite: 217].  This typically leads to faster convergence compared to the Jacobi method[cite: 228].",

    method_req_cramer_full_desc: "<b>1.  Dimension (N ≤ 4):</b> The number of determinant calculations grows rapidly, making the method inefficient for larger systems[cite: 44]. <br><b>2.  Non-singularity (det(A) ≠ 0):</b> If the determinant is zero, the system has no unique solution, and Cramer's rule is not applicable[cite: 35, 40].",
     method_req_iterative_full_desc: "For guaranteed convergence of iterative methods (Jacobi and Seidel), it is sufficient for the matrix \\(A\\) to be **diagonally dominant**[cite: 117].  This means that for each row, the absolute value of the diagonal element must be strictly greater than the sum of the absolute values of all other elements in that row: \\(|a_{kk}| > \\sum_{j \\neq k} |a_{kj}|\\)[cite: 118]. If this condition is not met, the method may diverge.",
     method_req_gauss_full_desc: "Gauss and Gauss-Jordan methods are universal and robust for solving general linear systems[cite: 232, 233]. The only key requirement is that the matrix \\(A\\) must be **non-singular** (i.e., \\(\\det(A) \\neq 0\\)), which guarantees a unique solution. They are applicable to any square system.",

    file_requirements_full_desc: "For correct parsing, the file must adhere to the following format:",
    file_format_N: "<b>Line 1:</b> A single integer N — the order of the system.",
    file_format_Matrix: "<b>Next N lines:</b> Each line represents a row of the augmented matrix `[A|b]`, containing N coefficients and the (N+1)-th element, which is the corresponding free term.",
    file_format_Separator: "<b>Separator:</b> All numbers in a line must be separated by spaces.",
    
    file_example_title: "File example for N=3",
    file_example_content: `3 <span class="comment"># System order</span>
    2.5 -1.0 4.2 10.1 <span class="comment"># a11 a12 a13 b1</span>
    1.1  6.0 -0.5 15.7 <span class="comment"># a21 a22 a23 b2</span>
    0.8  2.3  5.4 20.0 <span class="comment"># a31 a32 a33 b3</span>`,
    error_first_line_must_be_n: "The first line must contain only N — the number of equations.",
    error_n_out_of_bounds: "N={{n}} is out of allowed range (1–9).",
    error_expected_rows_n: "Expected {{n}} lines after N, got {{actual}}.",
    error_row_expected_len: "Row {{r}} must contain {{expected}} values (A|b), got {{actual}}.",
    error_non_numeric: "Non-numeric value \"{{s}}\" at row {{r}}, col {{c}}.",
    error_file_empty: "The file is empty.",
    error_file_read: "Failed to read file.",
    success_file_parsed: "File parsed successfully!",
    cramer_det_Ai: "Calculate the determinant of matrix A{{i}}",
      },
};